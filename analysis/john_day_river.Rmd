---
title: "John_Day_River"
author: "Markus Min"
date: "1/5/2022"
output: html_document
---

In this Rmd we will be recreating Shelby Richins' results for John Day River Steelhead.

NOTE: PIT tag detectors were only installed in the two adult fish ladders at John Day Dam in 2017. So from 2005-2015 we last see them at the Dalles Dam, and then in the John Day River


# PTAGIS Query

## Query 1 - adult returns to BON
- Interrogation Detail

Query Builder2:
- 1 Attributes: Standard
- 2 Metrics: Obs Count, Obs Time Max, Obs Time Min
- 9 Mark Site Subbasin == Upper John Day, North Fork John Day, Middle Fork John Day, Lower John Day
  - Searched "John Day" and selected all
- 16 Obs Time: Value between 6/1/2005 12:00:00 AM and 5/31/2015 11:59:59
- 17 Obs Site: BO1 - Bonneville Bradford Is. Ladder, BO2 - Bonneville Cascades Is. Ladder, BO3 - Bonneville WA Shore Ladder/AFF, BO4 - Bonneville WA Ladder Slots
- 24 Species: Steelhead
- 29 Mark Length: Less than or equal to 350


### Examine data

#### Load libraries
```{r load_libraries}
library(tidyverse)
library(here)
library(janitor)
library(lubridate)
```

#### Import data
```{r load_data}
JDR_BON_adult_returns <- clean_names(read.csv(here("PTAGIS_queries", "intermediate_files",  "2022-01-06-john_day_river_bon_adult_returns_2005-2015.csv")))
```

#### Inspect data
```{r}
# Unique tags?
length(unique(JDR_BON_adult_returns$tag_code))
# 2,121 unique tags - and they're all wild (or unknown)! This matches Shelby's numbers for wild fish.

# Count by year
# Reformat dates
JDR_BON_adult_returns %>% 
  mutate(obs_time_value = mdy_hms(obs_time_value)) %>% 
  mutate(year = year(obs_time_value)) -> JDR_BON_adult_returns
```

#### Export tags for querying PTAGIS
```{r}
as.data.frame(unique(JDR_BON_adult_returns$tag_code)) -> JDR_unique_tags

write.table(JDR_unique_tags, file = here(here("PTAGIS_queries", "intermediate_files",  "2022-01-06-john_day_river_bon_adult_returns_2005-2015_TAGS.txt")), col.names = FALSE, row.names = FALSE, quote = FALSE)
```

## QUERY 2
- Complete tag history

Query Builder2:
- 1 Attributes: Standard plus event site metadata fields: Event Site Basin, Event Site Info, Event Site Code, Event Site Subbasin, Event Site RKM
- 2 Metrics: Standard
- 29 Tag Code: 2022-01-06-john_day_river_bon_adult_returns_2005-2015_TAGS.txt

# Analysis

## Import and clean data
```{r}
JDR_CTH <- clean_names(read.csv(here("PTAGIS_queries", "complete_tag_histories", "2022-01-07-jdr_2005_2015_complete_tag_history.csv")))
JDR_CTH %>% 
  mutate(event_date = mdy(event_date_mmddyyyy)) %>% 
  arrange(tag_code, event_date) %>% 
  dplyr::select(tag_code, event_type_name, event_site_name, event_site_basin_name, event_site_subbasin_name, event_site_rkm_value, cth_count, event_date) -> JDR_CTH

JDR_CTH
```


Determine run timing based on the date/time of first observation at:
- Bonneville Dam
- overshoot dams (first dam with PIT detection capabilities upstream of the natal tributary)
  - Look in adult latter, or time of first observation above overshoot dam
- in natal tributary

Sort into run years by June 1

## Turn each detection history into characterization of run timing

### Make a df to sort by run year
```{r}
run_year <- c("05/06", "06/07", "07/08", "08/09", "09/10", "10/11", "11/12", "12/13", "13/14", "14/15")
run_year_start <- seq(ymd("2005-06-01"), ymd("2014-06-01"), by = "years")
run_year_end <- seq(ymd("2006-05-31"), ymd("2015-05-31"), by = "years")

run_year_df <- data.frame(run_year, run_year_start, run_year_end)

subset(run_year_df, run_year_start < BON_arrival_date & run_year_end > BON_arrival_date)$run_year
```



### Determine tally-based overshoot, homing, fallback rates
```{r detection_history_to_classification}
# Get a vector of all unique tags
unique_tags <- unique(JDR_CTH$tag_code)

# Figure out all the places where fish were detected
as.data.frame(table(JDR_CTH$event_site_name))

# Make a dataframe of the sites and their metadata
JDR_CTH[!duplicated(JDR_CTH$event_site_name),] %>% 
  dplyr::select(-c(tag_code, event_type_name, cth_count, event_date)) -> site_metadata
  
  

# Get the names of all Bonneville adult fishway detectors
BON_adult_fishways <- c("BHL - Adult Fishway at BONH", "BO1 - Bonneville Bradford Is. Ladder", "BO2 - Bonneville Cascades Is. Ladder", "BO3 - Bonneville WA Shore Ladder/AFF", "BO4 - Bonneville WA Ladder Slots", "BONAFF - BON - Adult Fish Facility")

# Get the names of all in stream arrays in John Day River
JDR_instream_arrays <- subset(site_metadata, event_site_basin_name == "John Day")$event_site_name

# Get the names of all arrays that would indicate overshoot (primarily McNary dam, but also other upstream arrays)
overshoot_arrays <- subset(site_metadata, event_site_basin_name %in% c("Lower Snake", "Clearwater", "Salmon", "Upper Columbia", "Yakima")  | event_site_subbasin_name %in% c("Middle Columbia-Lake Wallula", "Umatilla", "Walla Walla" ))$event_site_name

# Make a dataframe to store the fish status
overshoot_df <- data.frame(tag = unique_tags, run_year = NA, overshoot = NA, home = NA, fallback = NA)

# For each of the unique tags
for (i in 1:length(unique_tags)){
  tag_ID <- unique_tags[i]
  tag_hist <- subset(JDR_CTH, tag_code == tag_ID)
  
  # Get the date of arrival at BON - take min in case it fell back over Bonneville
  BON_arrival_date <- min(subset(tag_hist, event_site_name %in% c("BHL - Adult Fishway at BONH", "BO1 - Bonneville Bradford Is. Ladder", "BO2 - Bonneville Cascades Is. Ladder", "BO3 - Bonneville WA Shore Ladder/AFF", "BO4 - Bonneville WA Ladder Slots", "BONAFF - BON - Adult Fish Facility"))$event_date)
  
  # Assign the fish to the correct run year
  overshoot_df[i,2] <- subset(run_year_df, run_year_start < BON_arrival_date & run_year_end > BON_arrival_date)$run_year
  
  # Arrange by date
  tag_hist %>% 
    arrange(event_date) %>% 
    # Remove all detections that occur before detection at Bonneville upstream
    subset(., event_date >= BON_arrival_date) -> tag_hist_adult
  
  # Determine if overshot
  tag_hist_adult$event_site_name %in% overshoot_arrays -> overshoot_TF
  if (TRUE %in% overshoot_TF){
    overshoot_df[i,3] <- TRUE
  }
  else{
    overshoot_df[i,3] <- FALSE
  }
  
  # If it made it home, home = TRUE
  tag_hist_adult$event_site_name %in% JDR_instream_arrays -> instream_TF
  if (TRUE %in% instream_TF){
    overshoot_df[i,4] <- TRUE
  }
  else{
    overshoot_df[i,4] <- FALSE
  }
}
```
## Examine rates

### Total success rate
```{r}
table(overshoot_df$home)

# Tally estimate suggests only 32.39% successfully homed. But that is a big underestimate because detection efficiency in the natal tributary is far from 100%.
# According to Shelby's estimate, tally underestimates successful homing by about 8%
# Table A.2 (PDF page 154) - detection efficiency at JD1 mean of 71%, but is around 99% from 08-09 to 10/11, then drops to 40ish% from 12/13 to 14/15.
# Note in this table: “JD1” was washed out and replaced in 2011/2012

# Look into the detection histories of those that failed to home
failed_home_tags <- subset(overshoot_df, home == FALSE)$tag

subset(JDR_CTH, tag_code %in% failed_home_tags) %>% 
  dplyr::select(tag_code, event_site_name, event_site_subbasin_name, event_date) 


table(overshoot_df$run_year)
# The numbers are slightly different than Shelby's - I assume it's because of her manual editing of run years. From her thesis: 
# "Next, observations were sorted into run years. Because most populations of interior Columbia River basin steelhead normally begin their upstream migration in summer and spawn the following spring (Robards and Quinn 2002), 1 June was used as the division between run years. No date would be a perfect division between runs for all fish in all tributaries. To account for this, I manually examined the individual capture histories of all fish that had observations in consecutive run years and assigned fish to the correct run year or years. Some fish had single migrations that overlapped run years, with either early detections at downstream sites, or late detections indicating downstream movement after the spawning season. Other fish made multiple consecutive upstream migrations (successful kelts that returned as repeat spawners) and were kept in both run years."

# Look at the table of success rates by run year plus N
overshoot_df %>% 
  group_by(run_year) %>% 
  summarise(home_rate = sum(home), n = n()) %>% 
  mutate(home_rate = home_rate/n) -> total_success_tally_by_year

total_success_tally_by_year
# This looks very similar to Shelby's Figure A.3, for the years prior to 2012
# 2011/2012 is a wash because the array was down
```


### Overshoot
```{r}
table(overshoot_df$overshoot)

# Look at the table of success rates by run year plus N
overshoot_df %>% 
  group_by(run_year) %>% 
  summarise(overshoot_rate = sum(overshoot), n = n()) %>% 
  mutate(overshoot_rate = overshoot_rate/n) -> overshoot_tally_by_year

overshoot_tally_by_year
# These again look very similar to Shelby's results - Page 44, Fig 2.8
```

### Fallback to home
```{r}
overshoot_df %>% 
  mutate(fallback = ifelse(overshoot == TRUE & home == TRUE, TRUE,
                           ifelse(overshoot == TRUE & home == FALSE, FALSE, NA))) -> overshoot_df

# Look at the table of success rates by run year plus N
overshoot_df %>% 
  subset(., !is.na(fallback)) %>% 
  group_by(run_year) %>% 
  summarise(fallback_rate = sum(fallback), n = n()) %>% 
  mutate(fallback_rate = fallback_rate/n) -> fallback_tally_by_year

fallback_tally_by_year
# Looks similar to Shelby's Fig 2.11 (Page 38) - I think she only has estimates for 08/09, 09/10, 10/11, and then 12/13, 13/14, and 14/15 because of sample sizes
```



# Project Branch
DOESN'T WORK ON MacOS! Time to manually code these models...


# Multistate Release-Recapture Model

Let's see if we can write it in a maximum likelihood framework prior to going into JAGS/Bayesian.

For pre-2017 John Day River Steelhead:

Probability of being seen overshooting at MCN (for fish seen at Bonneville):

prob(moving from BON -> TDA) * prob(detection at TDA) * prob(moving from TDA -> MCN) * prob(detection at MCN)

"Models of John Day and Umatilla populations did not include early migration success, because the first dam with adult detectors below the home tributary was Bonneville Dam." (Richins 2017)
- So it sounds like we should ignore the Dalles, because apparently the adult detectors there didn't really work?

See Table E.1 (page 198): conditional overshoot rates
- Calculated for BON -> MCN, MCN -> ICH, ICH -> LGR, and MCN -> PRA
- TDA isn't mentioned

For other tables of conditional overshoot rates, it's the dam below the natal tributary to the dams upstream. So we're only looking at the first dam below natal tributary with adult detectors, which apparently doesn't include TDA.

## Get data into format for multinomial likelihood
```{r reformat_data}

JDR_CTH[!duplicated(JDR_CTH$event_site_name),] %>% 
  dplyr::select(-c(tag_code, event_type_name, cth_count, event_date)) -> site_metadata
  

# Get the names of all Bonneville adult fishway detectors
BON_adult_fishways <- c("BHL - Adult Fishway at BONH", "BO1 - Bonneville Bradford Is. Ladder", "BO2 - Bonneville Cascades Is. Ladder", "BO3 - Bonneville WA Shore Ladder/AFF", "BO4 - Bonneville WA Ladder Slots", "BONAFF - BON - Adult Fish Facility")

# Get names of all The Dalles adult fishway detectors
site_metadata$event_site_name[grep("Dalles", site_metadata$event_site_name)]
TDA_adult_fishways <- c("TD1 - The Dalles East Fish Ladder", "TD2 - The Dalles North Fish Ladder")

# Get names of all McNary adult fishway detectors
site_metadata$event_site_name[grep("McNary", site_metadata$event_site_name)]
MCN_adult_fishways <- c("MC1 - McNary Oregon Shore Ladder",  "MC2 - McNary Washington Shore Ladder")

# Get names of all ICH adult fishway detectors
site_metadata$event_site_name[grep("Ice", site_metadata$event_site_name)]
ICH_adult_fishways <- c("ICH - Ice Harbor Dam (Combined)")

# Get names of all LGR adult fishway detectors
site_metadata$event_site_name[grep("Granite", site_metadata$event_site_name)]
LGR_adult_fishways <- c("GRA - Lower Granite Dam Adult")

# Get names of all PRA adult fishway detectors
site_metadata$event_site_name[grep("Priest", site_metadata$event_site_name)]
PRA_adult_fishways <- c("PRA - Priest Rapids Adult")

# Get the names of all in stream arrays in John Day River
JDR_instream_arrays <- subset(site_metadata, event_site_basin_name == "John Day")$event_site_name

# Get the names of all arrays that would indicate overshoot (primarily McNary dam, but also other upstream arrays)
overshoot_arrays <- subset(site_metadata, event_site_basin_name %in% c("Lower Snake", "Clearwater", "Salmon", "Upper Columbia", "Yakima")  | event_site_subbasin_name %in% c("Middle Columbia-Lake Wallula", "Umatilla", "Walla Walla" ))$event_site_name

# Make a dataframe to store fish detection history
detection_df <- data.frame(tag = unique_tags, run_year = NA, BON = NA, TDA = NA, MCN = NA, ICH = NA, LGR = NA, PRA = NA, natal = NA)

# Record that they were seen at BON
detection_df$BON <- TRUE

# For each of the unique tags
for (i in 1:length(unique_tags)){
  tag_ID <- unique_tags[i]
  tag_hist <- subset(JDR_CTH, tag_code == tag_ID)
  
  # Get the date of arrival at BON - take min in case it fell back over Bonneville
  BON_arrival_date <- min(subset(tag_hist, event_site_name %in% c("BHL - Adult Fishway at BONH", "BO1 - Bonneville Bradford Is. Ladder", "BO2 - Bonneville Cascades Is. Ladder", "BO3 - Bonneville WA Shore Ladder/AFF", "BO4 - Bonneville WA Ladder Slots", "BONAFF - BON - Adult Fish Facility"))$event_date)
  
  # Assign the fish to the correct run year
  detection_df[i,2] <- subset(run_year_df, run_year_start < BON_arrival_date & run_year_end > BON_arrival_date)$run_year
  
  # Arrange by date
  tag_hist %>% 
    arrange(event_date) %>% 
    # Remove all detections that occur before detection at Bonneville upstream
    subset(., event_date >= BON_arrival_date) -> tag_hist_adult
  
  
  # Record if seen at TDA
  tag_hist_adult$event_site_name %in% TDA_adult_fishways -> TDA_TF
  if (TRUE %in% TDA_TF){
    detection_df[i,4] <- TRUE
  }
  else{
    detection_df[i,4] <- FALSE
  }
  
  # Record if seen at MCN
  tag_hist_adult$event_site_name %in% MCN_adult_fishways -> MCN_TF
  if (TRUE %in% MCN_TF){
    detection_df[i,5] <- TRUE
  }
  else{
    detection_df[i,5] <- FALSE
  }
    
  # Record if seen at ICH
  tag_hist_adult$event_site_name %in% ICH_adult_fishways -> ICH_TF
  if (TRUE %in% ICH_TF){
    detection_df[i,6] <- TRUE
  }
  else{
    detection_df[i,6] <- FALSE
  }
  
  # Record if seen at LGR
  tag_hist_adult$event_site_name %in% LGR_adult_fishways -> LGR_TF
  if (TRUE %in% LGR_TF){
    detection_df[i,7] <- TRUE
  }
  else{
    detection_df[i,7] <- FALSE
  }
  
  # Record if seen at PRA
  tag_hist_adult$event_site_name %in% PRA_adult_fishways -> PRA_TF
  if (TRUE %in% PRA_TF){
    detection_df[i,8] <- TRUE
  }
  else{
    detection_df[i,8] <- FALSE
  }
  
  # If it made it home, natal = TRUE
  tag_hist_adult$event_site_name %in% JDR_instream_arrays -> instream_TF
  if (TRUE %in% instream_TF){
    detection_df[i,9] <- TRUE
  }
  else{
    detection_df[i,9] <- FALSE
  }
}

detection_df

# Summarise into counts by site
detection_df %>% 
  summarise_at(vars(BON:natal), sum) -> detection_counts_v1

detection_counts_v1
# Doesn't work - need transitions, not counts at each sites

# as.data.frame(table(JDR_CTH$event_site_name)) %>% 
#   arrange(desc(Freq))
```

## Get data into format for multinomial likelihood
```{r reformat_data}

JDR_CTH[!duplicated(JDR_CTH$event_site_name),] %>% 
  dplyr::select(-c(tag_code, event_type_name, cth_count, event_date)) -> site_metadata
  

# Get the names of all Bonneville adult fishway detectors
BON_adult_fishways <- c("BHL - Adult Fishway at BONH", "BO1 - Bonneville Bradford Is. Ladder", "BO2 - Bonneville Cascades Is. Ladder", "BO3 - Bonneville WA Shore Ladder/AFF", "BO4 - Bonneville WA Ladder Slots", "BONAFF - BON - Adult Fish Facility")

# Get names of all The Dalles adult fishway detectors
site_metadata$event_site_name[grep("Dalles", site_metadata$event_site_name)]
TDA_adult_fishways <- c("TD1 - The Dalles East Fish Ladder", "TD2 - The Dalles North Fish Ladder")

# Get names of all McNary adult fishway detectors
site_metadata$event_site_name[grep("McNary", site_metadata$event_site_name)]
MCN_adult_fishways <- c("MC1 - McNary Oregon Shore Ladder",  "MC2 - McNary Washington Shore Ladder")

# Get names of all ICH adult fishway detectors
site_metadata$event_site_name[grep("Ice", site_metadata$event_site_name)]
ICH_adult_fishways <- c("ICH - Ice Harbor Dam (Combined)")

# Get names of all LGR adult fishway detectors
site_metadata$event_site_name[grep("Granite", site_metadata$event_site_name)]
LGR_adult_fishways <- c("GRA - Lower Granite Dam Adult")

# Get names of all PRA adult fishway detectors
site_metadata$event_site_name[grep("Priest", site_metadata$event_site_name)]
PRA_adult_fishways <- c("PRA - Priest Rapids Adult")

# Get the names of all in stream arrays in John Day River
JDR_instream_arrays <- subset(site_metadata, event_site_basin_name == "John Day")$event_site_name

# Get the names of all arrays that would indicate overshoot (primarily McNary dam, but also other upstream arrays)
overshoot_arrays <- subset(site_metadata, event_site_basin_name %in% c("Lower Snake", "Clearwater", "Salmon", "Upper Columbia", "Yakima")  | event_site_subbasin_name %in% c("Middle Columbia-Lake Wallula", "Umatilla", "Walla Walla" ))$event_site_name

# Make a dataframe to store fish detection history
detection_df <- data.frame(tag = unique_tags, run_year = NA, BON = NA, BON_TDA = NA, BON_MCN = NA, MCN_ICH = NA, ICH_LGR = NA, MCN_PRA = NA, natal = NA)

# Record that they were seen at BON
detection_df$BON <- TRUE

# For each of the unique tags
for (i in 1:length(unique_tags)){
  tag_ID <- unique_tags[i]
  tag_hist <- subset(JDR_CTH, tag_code == tag_ID)
  
  # Get the date of arrival at BON - take min in case it fell back over Bonneville
  BON_arrival_date <- min(subset(tag_hist, event_site_name %in% c("BHL - Adult Fishway at BONH", "BO1 - Bonneville Bradford Is. Ladder", "BO2 - Bonneville Cascades Is. Ladder", "BO3 - Bonneville WA Shore Ladder/AFF", "BO4 - Bonneville WA Ladder Slots", "BONAFF - BON - Adult Fish Facility"))$event_date)
  
  # Assign the fish to the correct run year
  detection_df[i,2] <- subset(run_year_df, run_year_start < BON_arrival_date & run_year_end > BON_arrival_date)$run_year
  
  # Arrange by date
  tag_hist %>% 
    arrange(event_date) %>% 
    # Remove all detections that occur before detection at Bonneville upstream
    subset(., event_date >= BON_arrival_date) -> tag_hist_adult
  
  
  # Record if seen at BON & TDA (BON -> TDA)
  tag_hist_adult$event_site_name %in% TDA_adult_fishways -> TDA_TF
  if (TRUE %in% TDA_TF & detection_df[i,3] == TRUE){
    detection_df[i,4] <- TRUE
  }
  else{
    detection_df[i,4] <- FALSE
  }
  
  # Record if seen at BON & MCN (BON -> MCN)
  tag_hist_adult$event_site_name %in% MCN_adult_fishways -> MCN_TF
  if (TRUE %in% MCN_TF  & detection_df[i,3] == TRUE){
    detection_df[i,5] <- TRUE
  }
  else{
    detection_df[i,5] <- FALSE
  }
    
  # Record if seen at ICH & MCN (MCN -> ICH)
  tag_hist_adult$event_site_name %in% ICH_adult_fishways -> ICH_TF
  if (TRUE %in% MCN_TF & TRUE %in% ICH_TF){
    detection_df[i,6] <- TRUE
  }
  else{
    detection_df[i,6] <- FALSE
  }
  
  # Record if seen at ICH & LGR
  tag_hist_adult$event_site_name %in% LGR_adult_fishways -> LGR_TF
  if (TRUE %in% LGR_TF & TRUE %in% ICH_TF){
    detection_df[i,7] <- TRUE
  }
  else{
    detection_df[i,7] <- FALSE
  }
  
  # Record if seen at MCN & PRA
  tag_hist_adult$event_site_name %in% PRA_adult_fishways -> PRA_TF
  if (TRUE %in% PRA_TF & TRUE %in% MCN_TF){
    detection_df[i,8] <- TRUE
  }
  else{
    detection_df[i,8] <- FALSE
  }
  
  # If it made it home, natal = TRUE
  tag_hist_adult$event_site_name %in% JDR_instream_arrays -> instream_TF
  if (TRUE %in% instream_TF){
    detection_df[i,9] <- TRUE
  }
  else{
    detection_df[i,9] <- FALSE
  }
}

detection_df

# Summarise into counts by site
detection_df %>% 
  summarise_at(vars(BON:natal), sum) -> detection_counts

detection_counts

# Get rid of BON_TDA
detection_counts %>% 
  dplyr::select(-BON_TDA) -> detection_counts
```

## Reformat data - turn into three site detection history
```{r reformat_data}

JDR_CTH[!duplicated(JDR_CTH$event_site_name),] %>% 
  dplyr::select(-c(tag_code, event_type_name, cth_count, event_date)) -> site_metadata
  

# Get the names of all Bonneville adult fishway detectors
BON_adult_fishways <- c("BHL - Adult Fishway at BONH", "BO1 - Bonneville Bradford Is. Ladder", "BO2 - Bonneville Cascades Is. Ladder", "BO3 - Bonneville WA Shore Ladder/AFF", "BO4 - Bonneville WA Ladder Slots", "BONAFF - BON - Adult Fish Facility")

# Get names of all The Dalles adult fishway detectors
site_metadata$event_site_name[grep("Dalles", site_metadata$event_site_name)]
TDA_adult_fishways <- c("TD1 - The Dalles East Fish Ladder", "TD2 - The Dalles North Fish Ladder")

# Get names of all McNary adult fishway detectors
site_metadata$event_site_name[grep("McNary", site_metadata$event_site_name)]
MCN_adult_fishways <- c("MC1 - McNary Oregon Shore Ladder",  "MC2 - McNary Washington Shore Ladder")

# Get names of all ICH adult fishway detectors
site_metadata$event_site_name[grep("Ice", site_metadata$event_site_name)]
ICH_adult_fishways <- c("ICH - Ice Harbor Dam (Combined)")

# Get names of all LGR adult fishway detectors
site_metadata$event_site_name[grep("Granite", site_metadata$event_site_name)]
LGR_adult_fishways <- c("GRA - Lower Granite Dam Adult")

# Get names of all PRA adult fishway detectors
site_metadata$event_site_name[grep("Priest", site_metadata$event_site_name)]
PRA_adult_fishways <- c("PRA - Priest Rapids Adult")

# Get the names of all in stream arrays in John Day River
JDR_instream_arrays <- subset(site_metadata, event_site_basin_name == "John Day")$event_site_name

# Get the names of all arrays that would indicate overshoot (primarily McNary dam, but also other upstream arrays)
overshoot_arrays <- subset(site_metadata, event_site_basin_name %in% c("Lower Snake", "Clearwater", "Salmon", "Upper Columbia", "Yakima")  | event_site_subbasin_name %in% c("Middle Columbia-Lake Wallula", "Umatilla", "Walla Walla" ))$event_site_name

# Make a dataframe to store fish detection history
detection_df <- data.frame(tag = unique_tags, run_year = NA, BON = NA, TDA = NA, MCN = NA, ICH = NA, LGR = NA, PRA = NA, natal = NA)

# Record that they were seen at BON
detection_df$BON <- TRUE

# For each of the unique tags
for (i in 1:length(unique_tags)){
  tag_ID <- unique_tags[i]
  tag_hist <- subset(JDR_CTH, tag_code == tag_ID)
  
  # Get the date of arrival at BON - take min in case it fell back over Bonneville
  BON_arrival_date <- min(subset(tag_hist, event_site_name %in% c("BHL - Adult Fishway at BONH", "BO1 - Bonneville Bradford Is. Ladder", "BO2 - Bonneville Cascades Is. Ladder", "BO3 - Bonneville WA Shore Ladder/AFF", "BO4 - Bonneville WA Ladder Slots", "BONAFF - BON - Adult Fish Facility"))$event_date)
  
  # Assign the fish to the correct run year
  detection_df[i,2] <- subset(run_year_df, run_year_start < BON_arrival_date & run_year_end > BON_arrival_date)$run_year
  
  # Arrange by date
  tag_hist %>% 
    arrange(event_date) %>% 
    # Remove all detections that occur before detection at Bonneville upstream
    subset(., event_date >= BON_arrival_date) -> tag_hist_adult
  
  
  # Record if seen at TDA
  tag_hist_adult$event_site_name %in% TDA_adult_fishways -> TDA_TF
  if (TRUE %in% TDA_TF){
    detection_df[i,4] <- TRUE
  }
  else{
    detection_df[i,4] <- FALSE
  }
  
  # Record if seen at MCN
  tag_hist_adult$event_site_name %in% MCN_adult_fishways -> MCN_TF
  if (TRUE %in% MCN_TF){
    detection_df[i,5] <- TRUE
  }
  else{
    detection_df[i,5] <- FALSE
  }
    
  # Record if seen at ICH
  tag_hist_adult$event_site_name %in% ICH_adult_fishways -> ICH_TF
  if (TRUE %in% ICH_TF){
    detection_df[i,6] <- TRUE
  }
  else{
    detection_df[i,6] <- FALSE
  }
  
  # Record if seen at LGR
  tag_hist_adult$event_site_name %in% LGR_adult_fishways -> LGR_TF
  if (TRUE %in% LGR_TF){
    detection_df[i,7] <- TRUE
  }
  else{
    detection_df[i,7] <- FALSE
  }
  
  # Record if seen at PRA
  tag_hist_adult$event_site_name %in% PRA_adult_fishways -> PRA_TF
  if (TRUE %in% PRA_TF){
    detection_df[i,8] <- TRUE
  }
  else{
    detection_df[i,8] <- FALSE
  }
  
  # If it made it home, natal = TRUE
  tag_hist_adult$event_site_name %in% JDR_instream_arrays -> instream_TF
  if (TRUE %in% instream_TF){
    detection_df[i,9] <- TRUE
  }
  else{
    detection_df[i,9] <- FALSE
  }
}

detection_df

### Turn this into detection history
# det_hist <- data.frame(det_hist <- c("111", "110", "101", "100", "011", "010", "001", "000"))
detection_df %>% 
  mutate(det_hist = ifelse(MCN == TRUE & ICH == TRUE & LGR == TRUE, "111", #111 - seen at MCN, ICH, & LGR
                           ifelse(MCN == TRUE & ICH == TRUE & LGR == FALSE, "110", #111 - seen at MCN, seen atICH, not LGR
                                  ifelse(MCN == TRUE & ICH == FALSE & LGR == TRUE, "101", #111 - seen at MCN, not seen ICH, seen LGR
                                         ifelse(MCN == TRUE & ICH == FALSE & LGR == FALSE, "100", #100 - seen at MCN, not ICH, not LGR
                                                ifelse(MCN == FALSE & ICH == TRUE & LGR == TRUE, "011", #111 - seen at MCN, ICH, & LGR
                                                       ifelse(MCN == FALSE & ICH == TRUE & LGR == FALSE, "010", #111 - not seen MCN, seen ICH, not seen LGR
                                                              ifelse(MCN == FALSE & ICH == FALSE & LGR == TRUE, "001", #111 - only seen at LGR
                                                                     ifelse(MCN == FALSE & ICH == FALSE & LGR == FALSE, "000", #111 - not seen anywhere
                           "ERROR"))))))))) -> detection_df
```

## Multistate model - three site
Slide 26 from UCD workshop - through LGR - three site CJS
- first site: McNary
- second site: ICH
- third site: LGR

parameters:
- s1 = survival from BON to MCN
- s2 = survival from MCN to ICH
- s3 = survival from ICH to LGR
- p1 = detection probability at MCN
- p2 = detection probability at ICH
- p3 = detection probability at LGR

BUT - if we pretend there are no upstream arrays from LGR (PRA is in actuality), then we can't disentangle s3 from p3 - so we can use lambda to represent s3 * p3

```{r}
table(detection_df$det_hist) %>% 
  as.data.frame() %>% 
  dplyr::rename(det_hist = Var1, count = Freq) %>% 
  mutate(det_hist = as.character(det_hist)) %>% 
  bind_rows(., data.frame(det_hist = c("001", "101"), count = c(0,0))) %>% 
  arrange(desc(det_hist)) -> det_hist_df

# Pseudocode for MLE of parameters
# Five parameters (s1, p1, s2, p2, and lambda)
p.MLE = function(s1, p1, s2, p2, lambda){
  # Calculate the probabilities of the eight different detection histories from the five parameters above
  # Turns out we only see six detection histories - no 001, and no 101
  # But we can still treat the multinomial as having eight possible outcomes
  
  # 111
  n111 = s1 * p1 * s2 * p2 * lambda
  
  # 110
  n110 = s1 * p1 * s2 * p2 * (1 - lambda)
  
  # 101
  n101 = s1 * p1 * s2*(1 - p2) * lambda
  
  # 100
  # NOTE: I think this one (and some following ones) are incorrect. Anything that ends in two zeros "x00" should involve addition 
  n100 = s1 * p1 * (1 - s2 * p2) * (1 - lambda)
  
  # 011
  n011 = s1 * (1 - p1) * s2 * p2 * lambda
  
  # 010
  n010 = s1 * (1 - p1) * s2 * p2 * (1 - lambda)
  
  # 001
  n001 = s1 * (1 - p1) * s2 * (1 - p2) * lambda
  
  # 000
  n000 = (1 - s1) + (s1 * (1 - p1) * (1 - s2)) + (s1 * (1 - p1) * s2 * (1 - p2) * (1 - lambda))
  
  
  # Then, input those into dmultinom
  # except p here is a vector of probability
  p <- c(n111, n110, n101, n100, n011, n010, n001, n000)
  # negLL = function(p) (-1)*dbinom(y, size = n, prob = p, log = TRUE)
  negLL <- function(p) (-1) * dmultinom(x = det_hist_df$count, prob = p)
  
  # Use optim to optimize parameters to minimize NLL
  fit = optim(c(0.5, ), negLL, method = 'L-BFGS-B', hessian = TRUE, lower = 0.0001, upper = 0.9999)
  var = solve(fit$hessian)
  list(logLik = fit$value, MLE = fit$par, var = var)
}
p.MLE(n = 20, y = 12)


### ABOVE IS OLD

# params are in order: s1, p1, s2, p2, lambda
negLL = function(params, data){
  # Calculate the probabilities of the eight different detection histories from the five parameters above
  # Turns out we only see six detection histories - no 001, and no 101
  # But we can still treat the multinomial as having eight possible outcomes

  # Get parameters from params vector
  s1 <- params[1]
  p1 <- params[2]
  s2 <- params[3]
  p2 <- params[4]
  lambda <- params[5]

  # 111
  n111 = s1 * p1 * s2 * p2 * lambda
  
  # 110
  n110 = s1 * p1 * s2 * p2 * (1 - lambda)
  
  # 101
  n101 = s1 * p1 * s2*(1 - p2) * lambda
  
  # 100
  n100 = s1 * p1 * (1 - s2 * p2) * (1 - lambda)
  
  # 011
  n011 = s1 * (1 - p1) * s2 * p2 * lambda
  
  # 010
  n010 = s1 * (1 - p1) * s2 * p2 * (1 - lambda)
  
  # 001
  n001 = s1 * (1 - p1) * s2 * (1 - p2) * lambda
  
  # 000
  n000 = (1 - s1) + (s1 * (1 - p1) * (1 - s2)) + (s1 * (1 - p1) * s2 * (1 - p2) * (1 - lambda))
  
  
  # Then, input those into dmultinom
  # except p here is a vector of probability
  p <- c(n111, n110, n101, n100, n011, n010, n001, n000)
  # negLL = function(p) (-1)*dbinom(y, size = n, prob = p, log = TRUE)
  negLL <- -1* dmultinom(x = data$count, prob = p, log = TRUE)
}

# Use optim
# Use optim to optimize parameters to minimize NLL
# Order of parameters: s1, p1, s2, p2, lambda
# Hessian = TRUE crashes this
optim(par = c(0.5, 0.99, 0.5, 0.99, 0.2), data = det_hist_df, fn = negLL, method = 'L-BFGS-B', hessian = FALSE, lower = 0.1, upper = 0.9999)
# fit = optim(par = c(0.5, 0.99, 0.5, 0.99, 0.2), fn = negLL, method = "Nelder-Mead")
# var = solve(fit$hessian)
list(logLik = fit$value, MLE = fit$par, var = var)


```


## Reformat data - turn into four site detection history
```{r reformat_data}

JDR_CTH[!duplicated(JDR_CTH$event_site_name),] %>% 
  dplyr::select(-c(tag_code, event_type_name, cth_count, event_date)) -> site_metadata
  

# Get the names of all Bonneville adult fishway detectors
BON_adult_fishways <- c("BHL - Adult Fishway at BONH", "BO1 - Bonneville Bradford Is. Ladder", "BO2 - Bonneville Cascades Is. Ladder", "BO3 - Bonneville WA Shore Ladder/AFF", "BO4 - Bonneville WA Ladder Slots", "BONAFF - BON - Adult Fish Facility")

# Get names of all The Dalles adult fishway detectors
site_metadata$event_site_name[grep("Dalles", site_metadata$event_site_name)]
TDA_adult_fishways <- c("TD1 - The Dalles East Fish Ladder", "TD2 - The Dalles North Fish Ladder")

# Get names of all McNary adult fishway detectors
site_metadata$event_site_name[grep("McNary", site_metadata$event_site_name)]
MCN_adult_fishways <- c("MC1 - McNary Oregon Shore Ladder",  "MC2 - McNary Washington Shore Ladder")

# Get names of all ICH adult fishway detectors
site_metadata$event_site_name[grep("Ice", site_metadata$event_site_name)]
ICH_adult_fishways <- c("ICH - Ice Harbor Dam (Combined)")

# Get names of all LGR adult fishway detectors
site_metadata$event_site_name[grep("Granite", site_metadata$event_site_name)]
LGR_adult_fishways <- c("GRA - Lower Granite Dam Adult")

# Get names of all PRA adult fishway detectors
site_metadata$event_site_name[grep("Priest", site_metadata$event_site_name)]
PRA_adult_fishways <- c("PRA - Priest Rapids Adult")

# Get the names of all in stream arrays in John Day River
JDR_instream_arrays <- subset(site_metadata, event_site_basin_name == "John Day")$event_site_name

# Get the names of all arrays that would indicate overshoot (primarily McNary dam, but also other upstream arrays)
overshoot_arrays <- subset(site_metadata, event_site_basin_name %in% c("Lower Snake", "Clearwater", "Salmon", "Upper Columbia", "Yakima")  | event_site_subbasin_name %in% c("Middle Columbia-Lake Wallula", "Umatilla", "Walla Walla" ))$event_site_name

# Make a dataframe to store fish detection history
detection_df <- data.frame(tag = unique_tags, run_year = NA, BON = NA, TDA = NA, MCN = NA, ICH = NA, LGR = NA, PRA = NA, natal = NA)

# Record that they were seen at BON
detection_df$BON <- TRUE

# For each of the unique tags
for (i in 1:length(unique_tags)){
  tag_ID <- unique_tags[i]
  tag_hist <- subset(JDR_CTH, tag_code == tag_ID)
  
  # Get the date of arrival at BON - take min in case it fell back over Bonneville
  BON_arrival_date <- min(subset(tag_hist, event_site_name %in% c("BHL - Adult Fishway at BONH", "BO1 - Bonneville Bradford Is. Ladder", "BO2 - Bonneville Cascades Is. Ladder", "BO3 - Bonneville WA Shore Ladder/AFF", "BO4 - Bonneville WA Ladder Slots", "BONAFF - BON - Adult Fish Facility"))$event_date)
  
  # Assign the fish to the correct run year
  detection_df[i,2] <- subset(run_year_df, run_year_start < BON_arrival_date & run_year_end > BON_arrival_date)$run_year
  
  # Arrange by date
  tag_hist %>% 
    arrange(event_date) %>% 
    # Remove all detections that occur before detection at Bonneville upstream
    subset(., event_date >= BON_arrival_date) -> tag_hist_adult
  
  
  # Record if seen at TDA
  tag_hist_adult$event_site_name %in% TDA_adult_fishways -> TDA_TF
  if (TRUE %in% TDA_TF){
    detection_df[i,4] <- TRUE
  }
  else{
    detection_df[i,4] <- FALSE
  }
  
  # Record if seen at MCN
  tag_hist_adult$event_site_name %in% MCN_adult_fishways -> MCN_TF
  if (TRUE %in% MCN_TF){
    detection_df[i,5] <- TRUE
  }
  else{
    detection_df[i,5] <- FALSE
  }
    
  # Record if seen at ICH
  tag_hist_adult$event_site_name %in% ICH_adult_fishways -> ICH_TF
  if (TRUE %in% ICH_TF){
    detection_df[i,6] <- TRUE
  }
  else{
    detection_df[i,6] <- FALSE
  }
  
  # Record if seen at LGR
  tag_hist_adult$event_site_name %in% LGR_adult_fishways -> LGR_TF
  if (TRUE %in% LGR_TF){
    detection_df[i,7] <- TRUE
  }
  else{
    detection_df[i,7] <- FALSE
  }
  
  # Record if seen at PRA
  tag_hist_adult$event_site_name %in% PRA_adult_fishways -> PRA_TF
  if (TRUE %in% PRA_TF){
    detection_df[i,8] <- TRUE
  }
  else{
    detection_df[i,8] <- FALSE
  }
  
  # If it made it home, natal = TRUE
  tag_hist_adult$event_site_name %in% JDR_instream_arrays -> instream_TF
  if (TRUE %in% instream_TF){
    detection_df[i,9] <- TRUE
  }
  else{
    detection_df[i,9] <- FALSE
  }
}

detection_df

### Turn this into detection history
# det_hist <- data.frame(det_hist <- c("1111", "1110", "1101", "1100", "1011", "1010", "1001", "1000",
# "0111", "0110", "0101", "0100", "0011", "0010", "0001", "0000"))
# Keep concatenating numbers to detection history, instead of ifelse statements

detection_df %>% 
  mutate(det_hist = ifelse(MCN == TRUE, 1, 0)) %>% 
  mutate(det_hist = ifelse(ICH == TRUE, paste0(det_hist, 1), paste0(det_hist, 0))) %>% 
  mutate(det_hist = ifelse(LGR == TRUE, paste0(det_hist, 1), paste0(det_hist, 0))) %>% 
  mutate(det_hist = ifelse(PRA == TRUE, paste0(det_hist, 1), paste0(det_hist, 0))) -> detection_df
```

## Multistate model - four sites
Slide 26 from UCD workshop - through PRA - four site CJS
- first site: McNary
- second site: ICH
- third site: LGR
- fourth site: PRA

parameters:
- s1 = survival from BON to MCN
- s2 = survival from MCN to ICH
- s3 = survival from ICH to LGR
- s4 = survival from LGR to PRA
- p1 = detection probability at MCN
- p2 = detection probability at ICH
- p3 = detection probability at LGR
- p4 = detection probability at PRA

BUT - since no fish were detected at upstream arrays from PRA, then we can't disentangle s4 from p4 - so we can use lambda to represent s4 * p4

```{r}
# Get a vector of all possible detection histories
det_hist_possibilities_generator <- function(sites){
  l <- rep(list(c(0:1)), sites)
  det_hist_possibilities <- expand.grid(l)
  det_hist_possibilities %>% 
    mutate(det_hist = apply(., 1, paste, collapse="")) -> det_hist_possibilities
  det_hist_possibilities_vec <- det_hist_possibilities$det_hist
  return(det_hist_possibilities_vec)
}

# Generate a table of detection histories

# First get all possible histories
det_hist_options <- det_hist_possibilities_generator(sites = 4)
# Figure out which histories are not represented in the data
missing_hist <- setdiff(det_hist_options, unique(detection_df$det_hist))

table(detection_df$det_hist) %>% 
  as.data.frame() %>% 
  dplyr::rename(det_hist = Var1, count = Freq) %>% 
  mutate(det_hist = as.character(det_hist)) %>% 
  # Add all of the missing detection histories
  bind_rows(., data.frame(det_hist = missing_hist, count = rep(0, length(missing_hist)))) %>% 
  arrange(desc(det_hist)) -> det_hist_df

# params are in order: s1, p1, s2, p2, s3, p3, and lambda
negLL = function(params, data){
  # Calculate the probabilities of the 16 different detection histories from the 7 parameters above

  # Get parameters from params vector
  s1 <- params[1]
  p1 <- params[2]
  s2 <- params[3]
  p2 <- params[4]
  s3 <- params[5]
  p3 <- params[6]
  lambda <- params[7]

  # 1111
  n1111 <- s1 * p1 * s2 * p2 * s3 * p3 * lambda
  
  # 1110
  n1110 <- s1 * p1 * s2 * p2 * s3 * p3 * (1 - lambda)
  
  # 1101
  n1101 <- s1 * p1 * s2 * p2 * s3 * (1 - p3) * lambda
  
  # 1100
  n1100 <- s1 * p1 * s2 * p2 * (1 - s3) + # died between 2 and 3
    s1 * p1 * s2 * p2 * s3 *  (1 - p3) * (1 - lambda) # survived between 2 and 3 but not detected at 3, then didn't make it to 4
  
  # 1011
  n1011 <- s1 * p1 * s2 * (1 - p2) * s3 * p3 * lambda
  
  # 1010
  n1010 <- s1 * p1 * s2 * (1 - p2) * s3 * p3 * (1 - lambda)
  
  # 1001
  n1001 <- s1 * p1 * s2 * (1 - p2) * s3 * (1 - p3) * lambda
  
  # 1000
  n1000 <- s1 * p1 * (1 - s2) + # died between 1 and 2
    s1 * p1 * s2 * (1 - p2) * (1 - s3) + # made it to 2 undetected, died 2 -> 3
    s1 * p1 * s2 * (1 - p2) * s3 * (1 - p3) * (1 - lambda) # Made it to 2 and 3 undetected, didn't make it to 4
  
  # 0111
  n0111 <- s1 * (1 - p1) * s2 * p2 * s3 * p3 * lambda
  
  # 0110
  n0110 <- s1 * (1 - p1) * s2 * p2 * s3 * p3 * (1 - lambda)
  
  # 0101
  n0101 <- s1 * (1 - p1) * s2 * p2 * s3 * (1 - p3) * lambda
  
  # 0100
  n0100 <- s1 * (1 - p1) * s2 * p2 * (1 - s3) + # died between 2 and 3
    s1 * (1 - p1) * s2 * p2 * s3 *  (1 - p3) * (1 - lambda) # survived between 2 and 3 but not detected at 3, then didn't make it to 4
  
  # 0011
  n0011 <- s1 * (1 - p1) * s2 * (1 - p2) * s3 * p3 * lambda
  
  # 0010
  n0010 <- s1 * (1 - p1) * s2 * (1 - p2) * s3 * p3 * (1 - lambda)
  
  # 0001
  n0001 <- s1 * (1 - p1) * s2 * (1 - p2) * s3 * (1 - p3) * lambda
  
  # 0000
  n0000 <- (1 - s1) + # died before 1
    (s1 * (1 - p1) * (1 - s2)) + # survived undetected to 1, died 1 -> 2
    (s1 * (1 - p1) * s2 * (1 - p2) * (1 - s3)) + # survived undetected at 1 and 2, died 2 -> 3
    (s1 * (1 - p1) * s2 * (1 - p2) * s3 * (1 - p3) * (1 - lambda)) # survived undetected at 1 and 2 and 3, not seen at 4
  
  
  # Then, input those into dmultinom
  # except p here is a vector of probability
  p <- c(n1111, n1110, n1101, n1100, n1011, n1010, n1001, n1000,
         n0111, n0110, n0101, n0100, n0011, n0010, n0001, n0000)
  # negLL = function(p) (-1)*dbinom(y, size = n, prob = p, log = TRUE)
  negLL <- -1* dmultinom(x = data$count, prob = p, log = TRUE)
}

# Use optim
# Use optim to optimize parameters to minimize NLL
# Order of parameters: s1, p1, s2, p2, lambda
# Hessian = TRUE crashes this
optim(par = c(0.5, 0.99, 0.5, 0.99, 0.5, 0.99, 0.2), data = det_hist_df, fn = negLL, method = 'L-BFGS-B', hessian = FALSE, lower = 0.1, upper = 0.9999)
# fit = optim(par = c(0.5, 0.99, 0.5, 0.99, 0.2), fn = negLL, method = "Nelder-Mead")
# var = solve(fit$hessian)
# list(logLik = fit$value, MLE = fit$par, var = var)
```


### Writing the multinomial likelihood:

The parameters that we are estimating:

Migration successes (aka survival):
- BON_MCN
- MCN_ICH
- ICH_LGR
- MCN_PRA
- BON_natal
- overshoot_natal

Detection efficiency:
- MCN
- ICH
- LGR
- PRA
- natal

Choice of movement direction (branching)
- After Bonneville, they can either home directly (would be seen in natal tributary) OR they can overshoot MCN

Need to calculate overshoot rates (conditional and unconditional).

Richins 2017: Unconditional overshooting rates were calculated as the proportion of fish seen in the fish ladder of the overshot dam out of the number of fish seen at Bonneville, divided by the detection efficiency at the overshot dam in that run year (Eq. 2.2).

This is a branching system (not linear).

Let's do a simple system - just a linear system, looking at overshoot only at MCN.
- parameters:
  - survival BON -> MCN
  - survival BON -> natal
  - branch after BON; can overshoot (MCN) or home directly (natal)
  - detection efficiency at MCN
  - detection efficiency at natal

But I think that you need the upstream detectors too in order to estimate detection efficiency?



# Multistate model functions

## Data reformatting function
```{r reformat_data}

JDR_CTH[!duplicated(JDR_CTH$event_site_name),] %>% 
  dplyr::select(-c(tag_code, event_type_name, cth_count, event_date)) -> site_metadata
  

# Get the names of all Bonneville adult fishway detectors
BON_adult_fishways <- c("BHL - Adult Fishway at BONH", "BO1 - Bonneville Bradford Is. Ladder", "BO2 - Bonneville Cascades Is. Ladder", "BO3 - Bonneville WA Shore Ladder/AFF", "BO4 - Bonneville WA Ladder Slots", "BONAFF - BON - Adult Fish Facility")

# Get names of all The Dalles adult fishway detectors
site_metadata$event_site_name[grep("Dalles", site_metadata$event_site_name)]
TDA_adult_fishways <- c("TD1 - The Dalles East Fish Ladder", "TD2 - The Dalles North Fish Ladder")

# Get names of all McNary adult fishway detectors
site_metadata$event_site_name[grep("McNary", site_metadata$event_site_name)]
MCN_adult_fishways <- c("MC1 - McNary Oregon Shore Ladder",  "MC2 - McNary Washington Shore Ladder")

# Get names of all ICH adult fishway detectors
site_metadata$event_site_name[grep("Ice", site_metadata$event_site_name)]
ICH_adult_fishways <- c("ICH - Ice Harbor Dam (Combined)")

# Get names of all LGR adult fishway detectors
site_metadata$event_site_name[grep("Granite", site_metadata$event_site_name)]
LGR_adult_fishways <- c("GRA - Lower Granite Dam Adult")

# Get names of all PRA adult fishway detectors
site_metadata$event_site_name[grep("Priest", site_metadata$event_site_name)]
PRA_adult_fishways <- c("PRA - Priest Rapids Adult")

# Get the names of all in stream arrays in John Day River
JDR_instream_arrays <- subset(site_metadata, event_site_basin_name == "John Day")$event_site_name

# Get the names of all arrays that would indicate overshoot (primarily McNary dam, but also other upstream arrays)
overshoot_arrays <- subset(site_metadata, event_site_basin_name %in% c("Lower Snake", "Clearwater", "Salmon", "Upper Columbia", "Yakima")  | event_site_subbasin_name %in% c("Middle Columbia-Lake Wallula", "Umatilla", "Walla Walla" ))$event_site_name

# Make a dataframe to store fish detection history
detection_df <- data.frame(tag = unique_tags, run_year = NA, BON = NA, TDA = NA, MCN = NA, ICH = NA, LGR = NA, PRA = NA, natal = NA)

# Record that they were seen at BON
detection_df$BON <- TRUE

# For each of the unique tags
for (i in 1:length(unique_tags)){
  tag_ID <- unique_tags[i]
  tag_hist <- subset(JDR_CTH, tag_code == tag_ID)
  
  # Get the date of arrival at BON - take min in case it fell back over Bonneville
  BON_arrival_date <- min(subset(tag_hist, event_site_name %in% c("BHL - Adult Fishway at BONH", "BO1 - Bonneville Bradford Is. Ladder", "BO2 - Bonneville Cascades Is. Ladder", "BO3 - Bonneville WA Shore Ladder/AFF", "BO4 - Bonneville WA Ladder Slots", "BONAFF - BON - Adult Fish Facility"))$event_date)
  
  # Assign the fish to the correct run year
  detection_df[i,2] <- subset(run_year_df, run_year_start < BON_arrival_date & run_year_end > BON_arrival_date)$run_year
  
  # Arrange by date
  tag_hist %>% 
    arrange(event_date) %>% 
    # Remove all detections that occur before detection at Bonneville upstream
    subset(., event_date >= BON_arrival_date) -> tag_hist_adult
  
  
  # Record if seen at TDA
  tag_hist_adult$event_site_name %in% TDA_adult_fishways -> TDA_TF
  if (TRUE %in% TDA_TF){
    detection_df[i,4] <- TRUE
  }
  else{
    detection_df[i,4] <- FALSE
  }
  
  # Record if seen at MCN
  tag_hist_adult$event_site_name %in% MCN_adult_fishways -> MCN_TF
  if (TRUE %in% MCN_TF){
    detection_df[i,5] <- TRUE
  }
  else{
    detection_df[i,5] <- FALSE
  }
    
  # Record if seen at ICH
  tag_hist_adult$event_site_name %in% ICH_adult_fishways -> ICH_TF
  if (TRUE %in% ICH_TF){
    detection_df[i,6] <- TRUE
  }
  else{
    detection_df[i,6] <- FALSE
  }
  
  # Record if seen at LGR
  tag_hist_adult$event_site_name %in% LGR_adult_fishways -> LGR_TF
  if (TRUE %in% LGR_TF){
    detection_df[i,7] <- TRUE
  }
  else{
    detection_df[i,7] <- FALSE
  }
  
  # Record if seen at PRA
  tag_hist_adult$event_site_name %in% PRA_adult_fishways -> PRA_TF
  if (TRUE %in% PRA_TF){
    detection_df[i,8] <- TRUE
  }
  else{
    detection_df[i,8] <- FALSE
  }
  
  # If it made it home, natal = TRUE
  tag_hist_adult$event_site_name %in% JDR_instream_arrays -> instream_TF
  if (TRUE %in% instream_TF){
    detection_df[i,9] <- TRUE
  }
  else{
    detection_df[i,9] <- FALSE
  }
}

detection_df

### Turn this into detection history
# det_hist <- data.frame(det_hist <- c("1111", "1110", "1101", "1100", "1011", "1010", "1001", "1000",
# "0111", "0110", "0101", "0100", "0011", "0010", "0001", "0000"))
# Keep concatenating numbers to detection history, instead of ifelse statements

detection_df %>% 
  mutate(det_hist = ifelse(MCN == TRUE, "M", 0)) %>% 
  mutate(det_hist = paste0(det_hist, ifelse(ICH == TRUE, "I", 0))) %>% 
  mutate(det_hist = paste0(det_hist, ifelse(LGR == TRUE, "L", 0))) %>% 
  mutate(det_hist = paste0(det_hist, ifelse(PRA == TRUE, "P", 0)))  -> detection_df
  # mutate(det_hist = paste0(det_hist, ifelse(ICH == TRUE & LGR == TRUE, "IL",
  #                                           ifelse(ICH == TRUE & LGR == FALSE, "I0",
  #                                                  ifelse(ICH == FALSE & LGR == TRUE, "OL",
  #                                                         ifelse(PRA == TRUE, "P", "0")))))) -> detection_df

JDR_CTH %>% 
  subset(event_site_name %in% c(MCN_adult_fishways, ICH_adult_fishways, LGR_adult_fishways, PRA_adult_fishways)) %>% 
  mutate(tag_site = paste0(tag_code, event_site_name)) %>% 
  group_by(tag_code) %>% 
  subset(duplicated(tag_site)) -> intermediate_df

as.data.frame(table(intermediate_df$tag_code)) %>% 
  arrange(desc(Freq)) %>% 
  subset(Freq > 1) -> repeat_fish

repeat_fish_tag_codes <- repeat_fish$Var1

length(repeat_fish_tag_codes)
# 63/2121 fish seem to have ascended dams twice

# How much time 

subset(JDR_CTH, tag_code %in% repeat_fish_tag_codes) %>% 
  dplyr::select(tag_code, event_site_name,event_date) %>% 
  mutate(tag_site = paste0(tag_code, event_site_name)) %>% 
  # Subset only obs at dams
  subset(event_site_name %in% c(MCN_adult_fishways, ICH_adult_fishways, LGR_adult_fishways, PRA_adult_fishways)) %>% 
  dplyr::select(-tag_site) -> repeat_fish_dam_obs

subset(repeat_fish_dam_obs, tag_code == "3D9.1BF1CF04A0")
subset(repeat_fish_dam_obs, tag_code == "3D9.1C2C31825B")

length(unique(repeat_fish_dam_obs$tag_code))

subset(JDR_CTH, tag_code ==  "3D9.1BF1CF04A0") %>% 
  dplyr::select(tag_code, event_type_name, event_site_name, event_date)
subset(JDR_CTH, tag_code ==  "3D9.1C2C31825B") %>% 
  dplyr::select(tag_code, event_type_name, event_site_name, event_date)
```


## Model fitting function

### Prepare data for model
```{r prep_data_for_model}
# Get a vector of all possible detection histories
det_hist_possibilities_generator <- function(sites){
  l <- list(c("M", 0), c("I", 0), c("L", 0), c("P", 0))
  det_hist_possibilities <- expand.grid(l)
  det_hist_possibilities %>% 
    mutate(det_hist = apply(., 1, paste, collapse="")) -> det_hist_possibilities
  det_hist_possibilities_vec <- det_hist_possibilities$det_hist
  return(det_hist_possibilities_vec)
}

# Generate dfs for each run
run_year_df_generation <- function(run_year_name, complete_data){
  # Subset run year
  complete_data %>% 
    subset(., run_year == run_year_name) -> run_year_data
  
  # Now get all possible histories
  det_hist_options <- det_hist_possibilities_generator(sites = 4)
  # Figure out which histories are not represented in the data
  missing_hist <- setdiff(det_hist_options, unique(run_year_data$det_hist))
  
  # Now turn into detection history for model, adding in missing histories
  table(run_year_data$det_hist) %>% 
  as.data.frame() %>% 
  dplyr::rename(det_hist = Var1, count = Freq) %>% 
  mutate(det_hist = as.character(det_hist)) %>% 
  # Add all of the missing detection histories
  bind_rows(., data.frame(det_hist = missing_hist, count = rep(0, length(missing_hist)))) %>% 
  arrange(desc(det_hist)) -> det_hist_df
  
  return(det_hist_df)
}

data_05_06 <- run_year_df_generation(run_year_name = "05/06", complete_data = detection_df)
data_06_07 <- run_year_df_generation(run_year_name = "06/07", complete_data = detection_df)
data_07_08 <- run_year_df_generation(run_year_name = "07/08", complete_data = detection_df)
data_08_09 <- run_year_df_generation(run_year_name = "08/09", complete_data = detection_df)
data_09_10 <- run_year_df_generation(run_year_name = "09/10", complete_data = detection_df)
data_10_11 <- run_year_df_generation(run_year_name = "10/11", complete_data = detection_df)
data_11_12 <- run_year_df_generation(run_year_name = "11/12", complete_data = detection_df)
data_12_13 <- run_year_df_generation(run_year_name = "12/13", complete_data = detection_df)
data_13_14 <- run_year_df_generation(run_year_name = "13/14", complete_data = detection_df)
data_14_15 <- run_year_df_generation(run_year_name = "14/15", complete_data = detection_df)

# Look into some weird tag histories
subset(detection_df, det_hist == "MILP")$tag -> MILP_tags
subset(detection_df, det_hist == "MI0P")$tag -> MI0P_tags

subset(JDR_CTH, tag_code %in% c(MILP_tags, MI0P_tags)) -> funky_fish

# Each time, they went PRA first, then turned around and went up the Snake
```


### Fit model
```{r}
multistate_model <- function(data) {
  
  data <- data

# params are in order: sM, pM, sI, pI, lambdaL, lambdaP, psiI
negLL = function(params, data){
  # Calculate the probabilities of the 16 different detection histories from the 7 parameters above

  # Get parameters from params vector
  sM <- params[1]
  pM <- params[2]
  sI <- params[3]
  pI <- params[4]
  lambdaL <- params[5]
  lambdaP <- params[6]
  psiI <- params[7]

  
  # Put in zeros for non-realistic detection histories
  
  # MILP
  nMILP <- 0
  
  # MIL0
  nMIL0 <- sM * pM * psiI * sI * pI * lambdaL
  
  # MI0P
  nMI0P <- 0
  
  # MI00
  nMI00 <- sM * pM * psiI * sI * pI * (1 - lambdaL)
  
  # M0LP
  nM0LP <- 0
  
  # M0L0
  nM0L0 <- sM * pM * sI * (1 - pI) * lambdaL
  
  # M00P
  nM00P <- sM * pM * (1 - psiI) * lambdaP  
  
  # M000 - here we can't estimate survival between McNary dam and the branch
  nM000 <- sM * pM * psiI * (1 - sI) + # Chosen Ice Harbor route, died on way
    sM * pM * psiI * sI * (1 - pI) * (1 - lambdaL) + # Chosen Ice Harbor route, made it undetected
    sM * pM * (1 - psiI) * (1 - lambdaP) # Chose PRA route, not seen at PRA
  
  # 0ILP
  n0ILP <- 0
  
  # 0IL0
  n0IL0 <- sM * (1 - pM) * sI * pI * lambdaL
  
  # 0I0P
  n0I0P <- 0
  
  # 0I00
  n0I00 <- sM * (1 - pM) * sI * pI * (1 - lambdaL)
  
  # 00LP
  n00LP <- 0
  
  # 00L0
  n00L0 <- sM * (1 - pM) * sI * (1 - pI) * lambdaL
  
  # 000P
  n000P <- sM * (1 - pM) * lambdaP
  
  # 0000
  n0000 <- (1 - sM) + # died before MCN
    (sM * (1 - pM) * psiI * (1 - sI)) + # survived undetected to MCN, chose ICH route, died on way 
    (sM * (1 - pM) * psiI * sI * (1 - pI)) * (1 - lambdaL) + # survived undetected to MCN, chose ICH route, survived ICH undetected, not seen at LGR
    (sM * (1 - pM) * (1 - psiI) * (1 - lambdaP)) # survived undetected to MCN, chosen PRA route, not seen at PRA
  
  
  # Then, input those into dmultinom
  # p here is a vector of probability
  p <- c(nMILP, nMIL0, nMI0P, nMI00, nM0LP, nM0L0, nM00P, nM000,
         n0ILP, n0IL0, n0I0P, n0I00, n00LP, n00L0, n000P, n0000)
  # negLL = function(p) (-1)*dbinom(y, size = n, prob = p, log = TRUE)
  negLL <- -1* dmultinom(x = data$count, prob = p, log = TRUE)
}

# Use optim
# Use optim to optimize parameters to minimize NLL
# Order of parameters: sM, pM, sI, pI, lambdaL, lambdaP, psiI
# Hessian = TRUE crashes this
# We have to have a non-zero lower  bound, but we can round this later
optim_results <- optim(par = c(0.5, 0.99, 0.5, 0.99, 0.2, 0.2, 0.8), data = data, fn = negLL, method = 'L-BFGS-B', hessian = FALSE, lower = 0.0001, upper = 0.9999)
# fit = optim(par = c(0.5, 0.99, 0.5, 0.99, 0.2), fn = negLL, method = "Nelder-Mead")
# var = solve(fit$hessian)
# list(logLik = fit$value, MLE = fit$par, var = var)

return(optim_results)
}
```

### Run model fit function
```{r}
results_05_06 <- multistate_model(data = data_05_06)
results_06_07 <- multistate_model(data = data_06_07)
results_07_08 <- multistate_model(data = data_07_08)
# Doesn't work because we have fish exhibiting non-unidirectional movement - MILP
# results_08_09 <- multistate_model(data = data_08_09)
# Doesn't work because we have fish exhibiting non-unidirectional movement - MILP
# results_09_10 <- multistate_model(data = data_09_10)
results_10_11 <- multistate_model(data = data_10_11)
results_11_12 <- multistate_model(data = data_11_12)
results_12_13 <- multistate_model(data = data_12_13)
# Doesn't work because we have fish exhibiting non-unidirectional movement - MI0P
# results_13_14 <- multistate_model(data = data_13_14)
results_14_15 <- multistate_model(data = data_14_15)

# Concatenate all values in table, for comparison with Richins 2017 Table E.1 (Conditional overshooting rates)
# Parameter order: s1, p1, s2, p2, s3, p3, lambda

as.data.frame(results_05_06$par) %>% 
  bind_cols(as.data.frame(results_06_07$par)) %>% 
  bind_cols(as.data.frame(results_07_08$par)) %>% 
  # bind_cols(as.data.frame(results_08_09$par)) %>% 
  bind_cols(data.frame(results_08_09 = c(NA, NA, NA, NA, NA, NA, NA))) %>% 
  # bind_cols(as.data.frame(results_09_10$par)) %>% 
  bind_cols(data.frame(results_09_10 = c(NA, NA, NA, NA, NA, NA, NA))) %>% 
  bind_cols(as.data.frame(results_10_11$par)) %>% 
  bind_cols(as.data.frame(results_11_12$par)) %>% 
  bind_cols(as.data.frame(results_12_13$par)) %>% 
  # bind_cols(as.data.frame(results_13_14$par)) %>% 
  bind_cols(data.frame(results_13_14 = c(NA, NA, NA, NA, NA, NA, NA))) %>% 
  bind_cols(as.data.frame(results_14_15$par)) -> JDR_run_year_model_results

# Change upper and lower bound values to 0 and 1
JDR_run_year_model_results[JDR_run_year_model_results == 0.0001] <- 0
JDR_run_year_model_results[JDR_run_year_model_results == 0.9999] <- 1
  
# Change row and column names
rownames(JDR_run_year_model_results) <- c("BON -> MCN", "MCN p", "MCN -> ICH", "ICH p", "ICH -> LGR lambda", "MCN -> PRA lambda", "psiI")
colnames(JDR_run_year_model_results) <- c("05/06", "06/07", "07/08", "08/09", "09/10", "10/11", "11/12", "12/13", "13/14", "14/15")
# colnames(JDR_run_year_model_results) <- c("05/06", "06/07", "07/08", "10/11", "11/12", "12/13", "14/15")

JDR_run_year_model_results %>% 
  # Calculate the mean
  rowMeans(., na.rm = TRUE) %>% 
  as.data.frame() %>% 
  dplyr::rename("mean" = ".") -> value_means

JDR_run_year_model_results %>% 
  bind_cols(., value_means) -> JDR_run_year_model_results



data.frame(`05/06` = c(0.536, 0.337, 0.692, 0), 
           `06/07` = c(0.552, 0.227, 0.555, 0), 
           `07/08` = c(0.603, 0.134, 0, 0.029), 
           `08/09` = c(0.454, 0.416, 0.391, 0.09), 
           `09/10` = c(0.611, 0.295, 0.525, 0.014), 
           `10/11` = c(0.525, 0.296, 0.489, 0.048), 
           `11/12` = c(0.364, 0.271, 0.753, 0), 
           `12/13` = c(0.532, 0.075, 0.833, 0.025), 
           `13/14` = c(0.607, 0.129, 0.302, 0.019), 
           `14/15` = c(0.543, 0.261, 0.294, 0.015), 
           mean = c(0.533, 0.244, 0.483, 0.016),
  row.names = c("BON -> MCN", "MCN -> ICH", "ICH -> LGR", "MCN -> PRA")) -> Richins_Table_E1

colnames(Richins_Table_E1) <- colnames(JDR_run_year_model_results)
```

# Export these two tables using dput for use in the Rmd presentation
```{r export_tables_for_pres}
dput(JDR_run_year_model_results)
dput(Richins_Table_E1)
dput(head(dplyr::select(detection_df, -natal)))
dput(funky_fish)
```
